{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"seatable-api-php \u00b6 PHP-bindings of the SeaTable API ( api.seatable.io ). Requirements \u00b6 PHP 7.2.5+ (deprecated, 7.4+ recommended) with the Curl and Json extension (see composer.json ). Installation \u00b6 The SeaTable API installs as part of your project dependencies. It is available from Packagist for Composer : composer require seatable/seatable-api-php Upgrading \u00b6 This project is with Semantic Versioning (2.0.0) . Please see the notes on upgrading , especially for upgrading from the SeaTableAPI.php single class/file and other very early versions (0.x). Usage \u00b6 More connection options Please see Establish the Connection for an overview of all connection options, the following example is for getting started. Get Access to a Base \u00b6 SeaTable requires an additional authentication to get access to a specific base. There are two variants to obtain access. You can either: create within SeaTable an API-Token for a specific base - or - use your credentials, but then you have to provide the workspace_id and the name of the base. <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , # required for variant 2. 'password' => 'YOUR-PASSWORD' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // get access with your credentials (by workspace-id and table-name) $seatable -> getBaseAccessToken ( $workspaceID = 1323 , $name = 'Project tracker' ); // start using the available api calls to edit the data inside a base // ... Functions \u00b6 Admin Functions (User) \u00b6 sysAdminListUsers(int $page = 1, int $perPage = 25) sysAdminAddUser(string $email, string $name, string $password, string $role = 'default') sysAdminSearchUser(string $query) sysAdminUpdateUser(string $email, array $changes = []) sysAdminDeleteUser(string $email) Workspace Functions (Admin) \u00b6 updateBase(int $workspaceId, string $baseName, array $changes = []) copyBaseExternalLink(string $link, int $destinationWorkspaceId) Teammanagement Functions (Admin) \u00b6 Note: On the webpage SeaTable always talks about teams . The technical term that is used within the API documentation and manual is organization . sysAdminListTeams(int $page = 1, int $perPage = 25) sysAdminAddTeam(string $name, string $adminEmail, string $adminName, string $password, int $maxUser) sysAdminDeleteTeam(int $id) sysAdminUpdateTeam(int $id, array $changes = []) sysAdminListTeamUsers(int $id, int $page = 1, int $perPage = 25, bool $isStaff = false) sysAdminAddTeamUser(int $id, string $email, string $pass, string $name = null) sysAdminDeleteTeamUser(int $id, string $email) sysAdminListTeamGroups(int $id) sysAdminListTeamBases(int $id, int $page = 1, int $perPage = 25) Functions to Work with a Base (Table Data) \u00b6 listRows(string $tableName, string $viewName = null, bool $convertLinkId = false, string $orderBy = null, bool $direction = false, int $start = 0, int $limit = 1000) appendRow(string $tableName, array $row) getBaseMetadata() More functions will be added in the future. If you want to get a feeling about the usage of the functions, please have a look at the examples in the doc folder. Common Mistakes \u00b6 There are two kind of Email-Addresses in SeaTable \u00b6 There are two kind of email-addresses in SeaTable. Please don't be confused with the property email . There are two email addresses in SeaTable. Let's have a look at the user object in SeaTable: { \"data\": [ { \"email\": \"1ef456ab715841cc81b145b2530c2904@auth.local\", \"name\": \"Jane Doe\", \"contact_email\": \"jane@example.com, ... } ], \"total_count\": 1 } SeaTable creates for every user a unique identifier in form of an email address in the form of 1ef456ab715841cc81b145b2530c2904@auth.local . This unique identifier is used by the API calls to identify a user like in deleteOrgUser() . On the other hand a user registers with an email address for SeaTable. In this example this email is jane@example.com . This is the contact_email and only relevant for the authentication.","title":"Overview"},{"location":"#seatable-api-php","text":"PHP-bindings of the SeaTable API ( api.seatable.io ).","title":"seatable-api-php"},{"location":"#requirements","text":"PHP 7.2.5+ (deprecated, 7.4+ recommended) with the Curl and Json extension (see composer.json ).","title":"Requirements"},{"location":"#installation","text":"The SeaTable API installs as part of your project dependencies. It is available from Packagist for Composer : composer require seatable/seatable-api-php","title":"Installation"},{"location":"#upgrading","text":"This project is with Semantic Versioning (2.0.0) . Please see the notes on upgrading , especially for upgrading from the SeaTableAPI.php single class/file and other very early versions (0.x).","title":"Upgrading"},{"location":"#usage","text":"More connection options Please see Establish the Connection for an overview of all connection options, the following example is for getting started.","title":"Usage"},{"location":"#get-access-to-a-base","text":"SeaTable requires an additional authentication to get access to a specific base. There are two variants to obtain access. You can either: create within SeaTable an API-Token for a specific base - or - use your credentials, but then you have to provide the workspace_id and the name of the base. <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , # required for variant 2. 'password' => 'YOUR-PASSWORD' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // get access with your credentials (by workspace-id and table-name) $seatable -> getBaseAccessToken ( $workspaceID = 1323 , $name = 'Project tracker' ); // start using the available api calls to edit the data inside a base // ...","title":"Get Access to a Base"},{"location":"#functions","text":"","title":"Functions"},{"location":"#admin-functions-user","text":"sysAdminListUsers(int $page = 1, int $perPage = 25) sysAdminAddUser(string $email, string $name, string $password, string $role = 'default') sysAdminSearchUser(string $query) sysAdminUpdateUser(string $email, array $changes = []) sysAdminDeleteUser(string $email)","title":"Admin Functions (User)"},{"location":"#workspace-functions-admin","text":"updateBase(int $workspaceId, string $baseName, array $changes = []) copyBaseExternalLink(string $link, int $destinationWorkspaceId)","title":"Workspace Functions (Admin)"},{"location":"#teammanagement-functions-admin","text":"Note: On the webpage SeaTable always talks about teams . The technical term that is used within the API documentation and manual is organization . sysAdminListTeams(int $page = 1, int $perPage = 25) sysAdminAddTeam(string $name, string $adminEmail, string $adminName, string $password, int $maxUser) sysAdminDeleteTeam(int $id) sysAdminUpdateTeam(int $id, array $changes = []) sysAdminListTeamUsers(int $id, int $page = 1, int $perPage = 25, bool $isStaff = false) sysAdminAddTeamUser(int $id, string $email, string $pass, string $name = null) sysAdminDeleteTeamUser(int $id, string $email) sysAdminListTeamGroups(int $id) sysAdminListTeamBases(int $id, int $page = 1, int $perPage = 25)","title":"Teammanagement Functions (Admin)"},{"location":"#functions-to-work-with-a-base-table-data","text":"listRows(string $tableName, string $viewName = null, bool $convertLinkId = false, string $orderBy = null, bool $direction = false, int $start = 0, int $limit = 1000) appendRow(string $tableName, array $row) getBaseMetadata() More functions will be added in the future. If you want to get a feeling about the usage of the functions, please have a look at the examples in the doc folder.","title":"Functions to Work with a Base (Table Data)"},{"location":"#common-mistakes","text":"","title":"Common Mistakes"},{"location":"#there-are-two-kind-of-email-addresses-in-seatable","text":"There are two kind of email-addresses in SeaTable. Please don't be confused with the property email . There are two email addresses in SeaTable. Let's have a look at the user object in SeaTable: { \"data\": [ { \"email\": \"1ef456ab715841cc81b145b2530c2904@auth.local\", \"name\": \"Jane Doe\", \"contact_email\": \"jane@example.com, ... } ], \"total_count\": 1 } SeaTable creates for every user a unique identifier in form of an email address in the form of 1ef456ab715841cc81b145b2530c2904@auth.local . This unique identifier is used by the API calls to identify a user like in deleteOrgUser() . On the other hand a user registers with an email address for SeaTable. In this example this email is jane@example.com . This is the contact_email and only relevant for the authentication.","title":"There are two kind of Email-Addresses in SeaTable"},{"location":"UPGRADING/","text":"Upgrading \u00b6 This project is with Semantic Versioning (2.0.0) . This means that for the major version zero anything may change. Therefore, to ease use already for early versions, upgrade instructions for any such changes can be found in this document for an easy upgrade path. From very early Versions \u00b6 Change of Pagination Parameter Order (0.2.0) End of PHP 7.0 and PHP 7.1 support (0.2.0) Break of SeaTableApi::listOrgUsers() (0.1.20) Deprecation of SeaTableApi::getDTableToken() (0.1.11) Deprecation of PHP 7.0-7.3 (0.1.8) Removal of SeaTableAPI::debug() (0.1.7) New Classname (0.1.0) Curl SSL defaults (0.0.8) Upgrading from the SeaTableAPI.php Single Class/File (no version) Deprecations (0.x.x) Public Interface Change of Pagination Parameter Order (0.2.0) \u00b6 Version 0.2.0 corrects the non-intuitive order of the two pagination parameters (page and page size). Now first is the page number ( int $page ) and then size per page ( int $perPage ). These parameters always were with default values and the default values have not been changed. Otherwise, this is a backwards incompatible change, and it is without any additional deprecation or warning message. Affected methods are: \\SeaTable\\SeaTableApi\\SeaTableApi::listUsers \\SeaTable\\SeaTableApi\\SeaTableApi::listDailyActiveUsers \\SeaTable\\SeaTableApi\\SeaTableApi::listOrganizations \\SeaTable\\SeaTableApi\\SeaTableApi::listOrgUsers \\SeaTable\\SeaTableApi\\SeaTableApi::listOrgBases \\SeaTable\\SeaTableApi\\SeaTableApi::listAllSystemNotifications End of PHP 7.0 and PHP 7.1 support (0.2.0) \u00b6 As of version 0.1.8 PHP versions below PHP 7.4 were deprecated. With the release of version 0.2.0 the minimum PHP requirement is PHP 7.2.5. Break of SeaTableApi::listOrgUsers() (0.1.20) \u00b6 The $is_staff parameter of listOrgUsers() was broken and fixed in version 0.1.20. Unfortunately it could not be fixed without breaking backwards compatibility when using the $is_staff parameter. Previously when the $is_staff parameter was with the true default value, it was ineffective. Now the is_staff parameter is effective but the default value has changed to false . This ensures the behaviour is the same to previous but breaks in case the value true has been passed to obtain all users (admin and normal users) - true will now only return admin users. If true was in use to obtain all users, migrating to 0.1.20 requires to change $is_staff to false . Failing to do this will list admin users only . Upcoming Incompatible Changes in 0.2.x In 0.2.x the signature of the method will change with the $is_staff moved after the pagination parameters which will be swapped, too: 0.2.x: listOrgUsers(int $orgId, int $page = 1, int $perPage = 25, bool $isStaff = false): object 0.1.20: listOrgUsers($org_id, $is_staff = false, $per_page = 25, $page = 1) 0.1.19: listOrgUsers($org_id, $is_staff = true, $per_page = 25, $page = 1) Deprecation of SeaTableApi::getDTableToken() (0.1.11) \u00b6 The method getDTableToken() is deprecated. There are two new replacement methods to obtain a DTable Token: SeaTableApi::getBaseAppAccessToken() by the API Token SeaTableApi::getBaseAccessToken() by Workspace ID and DTable Name Deprecation of PHP 7.0-7.3 (0.1.8) \u00b6 With 0.1.8 the PHP versions below 7.4 are deprecated. Removal of SeaTableAPI::debug() (0.1.7) \u00b6 The in 0.0.4 deprecated SeaTableAPI::debug() method has been removed in 0.1.7. New Classname (0.1.0) \u00b6 If you previously used SeaTableAPI and you upgrade to version 0.1.0 or higher, replace it with SeaTableApi (lower-case pi at the end) from the new namespace SeaTable\\SeaTableApi . The use of the old class-name SeaTableAPI in the global namespace is deprecated with 0.1.0 and usages of the old class-name emit a deprecation notice ( E_USER_DEPRECATED ) on creation. Before: $seatable = new SeaTableAPI([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]); After: use SeaTable\\SeaTableApi\\SeaTableApi; $seatable = new SeaTableApi([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]); Curl SSL defaults (0.0.8) \u00b6 Version 0.0.8 changed to the cUrl library SSL defaults to improve security (and portability) for CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST . If you rely on non-default values for these two settings, you can pass them explicitly as options when creating the API class: $seatable = new SeaTableAPI([ 'http_options' => [ CURLOPT_SSL_VERIFYPEER => true, // always `false` before 0.0.8 CURLOPT_SSL_VERIFYHOST => 2, // always `false` before 0.0.8 ] ]); Upgrading from the SeaTableAPI.php Single Class/File (no version) \u00b6 If you previously just copied the SeaTableAPI.php file, you can replace it with the seatable/seatable-api-php composer package version 0.0.3: composer require seatable/seatable-api-php:0.0.3 Deprecations (0.x.x) \u00b6 For early versions, deprecations in the public interface are introduced not in minor but in patch versions. There is at least one patch version with the deprecation, and removal will not be before that patch version. Deprecations are @deprecated annotated and should trigger an E_USER_DEPRECATED error so that deprecations can be easily tracked while using. It then normally takes a couple of patch releases until a deprecated part of the public interface is fully removed. But note this must not necessarily be more than zero more patch releases and especially not a new minor release. However, expect the next minor release to not have the deprecated functionality any longer. In case it contains deprecation warnings from a previous minor release, expect it to not have the deprecated functionality any longer, the warning does not safeguard anything. To safely upgrade, test against your usage pattern with each patch version and handle the deprecations as early as possible. Public Interface \u00b6 Parts of the API marked as @internal are not part of the public interface and can change in any (patch) release. Parameters and return values in the public interface are still volatile and therefore not every of their properties can be easily guarded by deprecation warnings (or the PHP language itself). Even we do not take breaking changes lightly, please consider the following, more detailed information: Types of Parameters / Return Types \u00b6 If type-information for a parameter or a return value changes, the previous type-information unmatched by the change is considered deprecated, but not necessarily with a deprecation warning (for return-type-information a deprecation warning would likely not be useful if even possible). Run a type-checker to detect any issues with each patch release to be on the safe side: Changes in the signature (that have their effect with declare(strict_types=1) ) are not introduced in the same patch release unless the signature itself already contained the type-information for that parameter. That is before more strict and binding type-information is added, the information is annotated first. However, as the library uses declare(strict_types=1) internally, type errors may surface already earlier. Therefore, we suggest using the library with declare(strict_types=1) to narrow potential type related problems already when using the library. Named Parameters \u00b6 Calling any method or function of the public interface with named parameters (PHP 8.0+) is considered undefined behaviour. That is, it does not fall into any backward compatibility promise of any kind.","title":"Upgrading"},{"location":"UPGRADING/#upgrading","text":"This project is with Semantic Versioning (2.0.0) . This means that for the major version zero anything may change. Therefore, to ease use already for early versions, upgrade instructions for any such changes can be found in this document for an easy upgrade path.","title":"Upgrading"},{"location":"UPGRADING/#from-very-early-versions","text":"Change of Pagination Parameter Order (0.2.0) End of PHP 7.0 and PHP 7.1 support (0.2.0) Break of SeaTableApi::listOrgUsers() (0.1.20) Deprecation of SeaTableApi::getDTableToken() (0.1.11) Deprecation of PHP 7.0-7.3 (0.1.8) Removal of SeaTableAPI::debug() (0.1.7) New Classname (0.1.0) Curl SSL defaults (0.0.8) Upgrading from the SeaTableAPI.php Single Class/File (no version) Deprecations (0.x.x) Public Interface","title":"From very early Versions"},{"location":"UPGRADING/#change-of-pagination-parameter-order-020","text":"Version 0.2.0 corrects the non-intuitive order of the two pagination parameters (page and page size). Now first is the page number ( int $page ) and then size per page ( int $perPage ). These parameters always were with default values and the default values have not been changed. Otherwise, this is a backwards incompatible change, and it is without any additional deprecation or warning message. Affected methods are: \\SeaTable\\SeaTableApi\\SeaTableApi::listUsers \\SeaTable\\SeaTableApi\\SeaTableApi::listDailyActiveUsers \\SeaTable\\SeaTableApi\\SeaTableApi::listOrganizations \\SeaTable\\SeaTableApi\\SeaTableApi::listOrgUsers \\SeaTable\\SeaTableApi\\SeaTableApi::listOrgBases \\SeaTable\\SeaTableApi\\SeaTableApi::listAllSystemNotifications","title":"Change of Pagination Parameter Order (0.2.0)"},{"location":"UPGRADING/#end-of-php-70-and-php-71-support-020","text":"As of version 0.1.8 PHP versions below PHP 7.4 were deprecated. With the release of version 0.2.0 the minimum PHP requirement is PHP 7.2.5.","title":"End of PHP 7.0 and PHP 7.1 support (0.2.0)"},{"location":"UPGRADING/#break-of-seatableapilistorgusers-0120","text":"The $is_staff parameter of listOrgUsers() was broken and fixed in version 0.1.20. Unfortunately it could not be fixed without breaking backwards compatibility when using the $is_staff parameter. Previously when the $is_staff parameter was with the true default value, it was ineffective. Now the is_staff parameter is effective but the default value has changed to false . This ensures the behaviour is the same to previous but breaks in case the value true has been passed to obtain all users (admin and normal users) - true will now only return admin users. If true was in use to obtain all users, migrating to 0.1.20 requires to change $is_staff to false . Failing to do this will list admin users only . Upcoming Incompatible Changes in 0.2.x In 0.2.x the signature of the method will change with the $is_staff moved after the pagination parameters which will be swapped, too: 0.2.x: listOrgUsers(int $orgId, int $page = 1, int $perPage = 25, bool $isStaff = false): object 0.1.20: listOrgUsers($org_id, $is_staff = false, $per_page = 25, $page = 1) 0.1.19: listOrgUsers($org_id, $is_staff = true, $per_page = 25, $page = 1)","title":"Break of SeaTableApi::listOrgUsers() (0.1.20)"},{"location":"UPGRADING/#deprecation-of-seatableapigetdtabletoken-0111","text":"The method getDTableToken() is deprecated. There are two new replacement methods to obtain a DTable Token: SeaTableApi::getBaseAppAccessToken() by the API Token SeaTableApi::getBaseAccessToken() by Workspace ID and DTable Name","title":"Deprecation of SeaTableApi::getDTableToken() (0.1.11)"},{"location":"UPGRADING/#deprecation-of-php-70-73-018","text":"With 0.1.8 the PHP versions below 7.4 are deprecated.","title":"Deprecation of PHP 7.0-7.3 (0.1.8)"},{"location":"UPGRADING/#removal-of-seatableapidebug-017","text":"The in 0.0.4 deprecated SeaTableAPI::debug() method has been removed in 0.1.7.","title":"Removal of SeaTableAPI::debug() (0.1.7)"},{"location":"UPGRADING/#new-classname-010","text":"If you previously used SeaTableAPI and you upgrade to version 0.1.0 or higher, replace it with SeaTableApi (lower-case pi at the end) from the new namespace SeaTable\\SeaTableApi . The use of the old class-name SeaTableAPI in the global namespace is deprecated with 0.1.0 and usages of the old class-name emit a deprecation notice ( E_USER_DEPRECATED ) on creation. Before: $seatable = new SeaTableAPI([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]); After: use SeaTable\\SeaTableApi\\SeaTableApi; $seatable = new SeaTableApi([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]);","title":"New Classname (0.1.0)"},{"location":"UPGRADING/#curl-ssl-defaults-008","text":"Version 0.0.8 changed to the cUrl library SSL defaults to improve security (and portability) for CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST . If you rely on non-default values for these two settings, you can pass them explicitly as options when creating the API class: $seatable = new SeaTableAPI([ 'http_options' => [ CURLOPT_SSL_VERIFYPEER => true, // always `false` before 0.0.8 CURLOPT_SSL_VERIFYHOST => 2, // always `false` before 0.0.8 ] ]);","title":"Curl SSL defaults (0.0.8)"},{"location":"UPGRADING/#upgrading-from-the-seatableapiphp-single-classfile-no-version","text":"If you previously just copied the SeaTableAPI.php file, you can replace it with the seatable/seatable-api-php composer package version 0.0.3: composer require seatable/seatable-api-php:0.0.3","title":"Upgrading from the SeaTableAPI.php Single Class/File (no version)"},{"location":"UPGRADING/#deprecations-0xx","text":"For early versions, deprecations in the public interface are introduced not in minor but in patch versions. There is at least one patch version with the deprecation, and removal will not be before that patch version. Deprecations are @deprecated annotated and should trigger an E_USER_DEPRECATED error so that deprecations can be easily tracked while using. It then normally takes a couple of patch releases until a deprecated part of the public interface is fully removed. But note this must not necessarily be more than zero more patch releases and especially not a new minor release. However, expect the next minor release to not have the deprecated functionality any longer. In case it contains deprecation warnings from a previous minor release, expect it to not have the deprecated functionality any longer, the warning does not safeguard anything. To safely upgrade, test against your usage pattern with each patch version and handle the deprecations as early as possible.","title":"Deprecations (0.x.x)"},{"location":"UPGRADING/#public-interface","text":"Parts of the API marked as @internal are not part of the public interface and can change in any (patch) release. Parameters and return values in the public interface are still volatile and therefore not every of their properties can be easily guarded by deprecation warnings (or the PHP language itself). Even we do not take breaking changes lightly, please consider the following, more detailed information:","title":"Public Interface"},{"location":"UPGRADING/#types-of-parameters-return-types","text":"If type-information for a parameter or a return value changes, the previous type-information unmatched by the change is considered deprecated, but not necessarily with a deprecation warning (for return-type-information a deprecation warning would likely not be useful if even possible). Run a type-checker to detect any issues with each patch release to be on the safe side: Changes in the signature (that have their effect with declare(strict_types=1) ) are not introduced in the same patch release unless the signature itself already contained the type-information for that parameter. That is before more strict and binding type-information is added, the information is annotated first. However, as the library uses declare(strict_types=1) internally, type errors may surface already earlier. Therefore, we suggest using the library with declare(strict_types=1) to narrow potential type related problems already when using the library.","title":"Types of Parameters / Return Types"},{"location":"UPGRADING/#named-parameters","text":"Calling any method or function of the public interface with named parameters (PHP 8.0+) is considered undefined behaviour. That is, it does not fall into any backward compatibility promise of any kind.","title":"Named Parameters"},{"location":"doc/add-new-column-to-base/","text":"Example: Add a new Column to a Base \u00b6 Prerequisites \u00b6 You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read and write) the name of the table and the columns inside the base like table-name: Tasks columns of this table: Name , Description Example PHP-code \u00b6 <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // Append a row $row = [ 'Name' => \"New Task XYZ\" , 'Description' => \"This is a new description\" ]; $result = $seatable -> appendRow ( 'Tasks' , $row );","title":"Add a new Column to a Base"},{"location":"doc/add-new-column-to-base/#example-add-a-new-column-to-a-base","text":"","title":"Example: Add a new Column to a Base"},{"location":"doc/add-new-column-to-base/#prerequisites","text":"You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read and write) the name of the table and the columns inside the base like table-name: Tasks columns of this table: Name , Description","title":"Prerequisites"},{"location":"doc/add-new-column-to-base/#example-php-code","text":"<?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // Append a row $row = [ 'Name' => \"New Task XYZ\" , 'Description' => \"This is a new description\" ]; $result = $seatable -> appendRow ( 'Tasks' , $row );","title":"Example PHP-code"},{"location":"doc/establish-the-connection/","text":"Establish the Connection \u00b6 The SeaTable PHP Api authenticates on creation by passing the authentication options as an associative array with the keys as option names and the values as the option values. <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , 'password' => 'YOUR-PASSWORD' ]); // start using the available api calls echo $seatable -> ping (); Options \u00b6 url URL of the SeaTable server instance. Without a trailing slash. Depending on which authentication is preferred, other options are different. SeaTable Cloud Team-Admin Find your API Token and Base Tokens under API & Integrations (account.seatable.io) . Authentication Options \u00b6 Username+Password Authentication \u00b6 user Username as used in the frontend to login (email). password Password. Auth-Token Authentication \u00b6 auth_token The authentication token. In the SeaTable API Docs Authentication: a) User authentication (auth token) The SeaTable API uses a token to authenticate requests. This auth token can be created by an API request which requires username and password. As soon as you know your auth token, you do not need to provide your password again. An auth token is usually 40 characters long and is a kind of persistent master key for your account. Compare a) User authentication (auth token) in Authentication (api.seatable.io) . Base-App-API-Token Authentication \u00b6 base_app_api_token API token for the base app to authenticate against. base_app_name (optional) Name of the base app (can be given when creating the API token). Is verified when given. In the SeaTable API Docs Base API Token Base API Tokens are extremely useful if you would like a third-party integration to manipulate your base automatically for you. For each third-party App, you can create a unique App API Token for them and define read/write permissions. This token is then valid until you delete them. Compare Base API Token in Authentication (api.seatable.io) . The Base-Access-Token \u00b6 This form of authentication is used in the API and the SeaTable API PHP binding handles it during connection. It is not available with one of the authentication options above directly, instead it is acquired by the getBaseAccessToken() method to enable base access with Username+Password Authentication for a specific workspace and base. In the SeaTable API Docs Authentication: b) Base authentication (base access token) To access a SeaTable base or manipulate the data or structure of a base you need another token. This one is called base access token. This base access token is about 249 characters long and is only valid for three days. There are currently three ways to get this base access token: create a base access token from an API token (created at SeaTable web interface) create a base access token via auth token create a base access token via invite link token Compare b) Base authentication (base access token) in Authentication (api.seatable.io) . Legacy Information The pairing method getBaseAppAccessToken() is still available to obtain a base-access-token with the Base-App-API-Token Authentication token, but it is recommended to use the now existing option instead: base_app_api_token .","title":"Establish the Connection"},{"location":"doc/establish-the-connection/#establish-the-connection","text":"The SeaTable PHP Api authenticates on creation by passing the authentication options as an associative array with the keys as option names and the values as the option values. <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , 'password' => 'YOUR-PASSWORD' ]); // start using the available api calls echo $seatable -> ping ();","title":"Establish the Connection"},{"location":"doc/establish-the-connection/#options","text":"url URL of the SeaTable server instance. Without a trailing slash. Depending on which authentication is preferred, other options are different. SeaTable Cloud Team-Admin Find your API Token and Base Tokens under API & Integrations (account.seatable.io) .","title":"Options"},{"location":"doc/establish-the-connection/#authentication-options","text":"","title":"Authentication Options"},{"location":"doc/establish-the-connection/#usernamepassword-authentication","text":"user Username as used in the frontend to login (email). password Password.","title":"Username+Password Authentication"},{"location":"doc/establish-the-connection/#auth-token-authentication","text":"auth_token The authentication token. In the SeaTable API Docs Authentication: a) User authentication (auth token) The SeaTable API uses a token to authenticate requests. This auth token can be created by an API request which requires username and password. As soon as you know your auth token, you do not need to provide your password again. An auth token is usually 40 characters long and is a kind of persistent master key for your account. Compare a) User authentication (auth token) in Authentication (api.seatable.io) .","title":"Auth-Token Authentication"},{"location":"doc/establish-the-connection/#base-app-api-token-authentication","text":"base_app_api_token API token for the base app to authenticate against. base_app_name (optional) Name of the base app (can be given when creating the API token). Is verified when given. In the SeaTable API Docs Base API Token Base API Tokens are extremely useful if you would like a third-party integration to manipulate your base automatically for you. For each third-party App, you can create a unique App API Token for them and define read/write permissions. This token is then valid until you delete them. Compare Base API Token in Authentication (api.seatable.io) .","title":"Base-App-API-Token Authentication"},{"location":"doc/establish-the-connection/#the-base-access-token","text":"This form of authentication is used in the API and the SeaTable API PHP binding handles it during connection. It is not available with one of the authentication options above directly, instead it is acquired by the getBaseAccessToken() method to enable base access with Username+Password Authentication for a specific workspace and base. In the SeaTable API Docs Authentication: b) Base authentication (base access token) To access a SeaTable base or manipulate the data or structure of a base you need another token. This one is called base access token. This base access token is about 249 characters long and is only valid for three days. There are currently three ways to get this base access token: create a base access token from an API token (created at SeaTable web interface) create a base access token via auth token create a base access token via invite link token Compare b) Base authentication (base access token) in Authentication (api.seatable.io) . Legacy Information The pairing method getBaseAppAccessToken() is still available to obtain a base-access-token with the Base-App-API-Token Authentication token, but it is recommended to use the now existing option instead: base_app_api_token .","title":"The Base-Access-Token"},{"location":"doc/get-content-from-a-base/","text":"Example: Get Content from a Base \u00b6 Prerequisites \u00b6 You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read-only is enough) the name of the table like Articles the columns of this table: Status (single select) Description Title URL Example PHP-code \u00b6 <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b577c44709d459b33b6bac5ad1' ); // get all rows from the table Articles $rows = $seatable -> listRowsByView ( 'Articles' ); $reportsHtml = ' <ul class=\"my-reports\">' ; foreach ( $rows as $row ){ if ( $row -> Status === 'published' ) { $reportsHtml .= ' <li> <h2><a href=\"' . $row -> URL . '\" target=\"_blank\">' . htmlspecialchars ( $row -> Title , ENT_QUOTES | ENT_HTML5 ) . '</a></h2> <div class=\"desc> <p>' . htmlspecialchars ( $row -> Description , ENT_QUOTES | ENT_HTML5 ) . '</p> </div> </li>' ; }} $reportsHtml .= ' </ul>' ; echo $reportsHtml ;","title":"Get Content from a Base"},{"location":"doc/get-content-from-a-base/#example-get-content-from-a-base","text":"","title":"Example: Get Content from a Base"},{"location":"doc/get-content-from-a-base/#prerequisites","text":"You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read-only is enough) the name of the table like Articles the columns of this table: Status (single select) Description Title URL","title":"Prerequisites"},{"location":"doc/get-content-from-a-base/#example-php-code","text":"<?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b577c44709d459b33b6bac5ad1' ); // get all rows from the table Articles $rows = $seatable -> listRowsByView ( 'Articles' ); $reportsHtml = ' <ul class=\"my-reports\">' ; foreach ( $rows as $row ){ if ( $row -> Status === 'published' ) { $reportsHtml .= ' <li> <h2><a href=\"' . $row -> URL . '\" target=\"_blank\">' . htmlspecialchars ( $row -> Title , ENT_QUOTES | ENT_HTML5 ) . '</a></h2> <div class=\"desc> <p>' . htmlspecialchars ( $row -> Description , ENT_QUOTES | ENT_HTML5 ) . '</p> </div> </li>' ; }} $reportsHtml .= ' </ul>' ; echo $reportsHtml ;","title":"Example PHP-code"}]}