{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"seatable-api-php \u00b6 PHP-bindings of the SeaTable API ( api.seatable.io ). Requirements \u00b6 PHP 7.0+ (deprecated, 7.4+ recommended) with the Curl and Json extension (see composer.json ). Installation \u00b6 The SeaTable API installs as part of your project dependencies. It is available from Packagist for Composer : composer require seatable/seatable-api-php Upgrading \u00b6 This project is with Semantic Versioning (2.0.0) . Please see the notes on upgrading , especially for upgrading from the SeaTableAPI.php single class/file and other very early versions (0.x). Usage \u00b6 Establish the Connection \u00b6 <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , 'password' => 'YOUR-PASSWORD' ]); // start using the available api calls echo $seatable -> ping (); Get Access to a Base \u00b6 SeaTable requires an additional authentication to get access to a specific base. There are two variants to obtain access. You can either: create within SeaTable an API-Token for a specific base - or - use your credentials, but then you have to provide the workspace_id and the name of the base. <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , # required for variant 2. 'password' => 'YOUR-PASSWORD' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // get access with your credentials (by workspace-id and table-name) $seatable -> getBaseAccessToken ( $workspaceID = 1323 , $name = 'Project tracker' ); // start using the available api calls to edit the data inside a base // ... Functions \u00b6 Admin Functions (User) \u00b6 sysAdminListUsers(int $page = 1, int $perPage = 25) getTotalUsers() sysAdminAddUser(string $email, string $name, string $password, string $role = 'default') sysAdminSearchUser(string $query) sysAdminUpdateUser(string $email, array $changes = []) activateUser($email) deactivateUser($email) sysAdminDeleteUser(string $email) Workspace Functions (Admin) \u00b6 listAllWorkspaces() listStarredWorkspaces() updateBase(int $workspaceId, string $baseName, array $changes = []) copyBaseExternalLink(string $link, int $destinationWorkspaceId) Teammanagement Functions (Admin) \u00b6 Note: On the webpage SeaTable always talks about teams . The technical term that is used within the API documentation and manual is organization . sysAdminListTeams(int $page = 1, int $perPage = 25) sysAdminAddTeam(string $name, string $adminEmail, string $adminName, string $password, int $maxUser) sysAdminDeleteTeam(int $id) sysAdminUpdateTeam(int $id, array $changes = []) sysAdminListTeamUsers(int $id, int $page = 1, int $perPage = 25, bool $isStaff = false) sysAdminAddTeamUser(int $id, string $email, string $pass, string $name = null) sysAdminDeleteTeamUser(int $id, string $email) sysAdminListTeamGroups(int $id) sysAdminListTeamBases(int $id, int $page = 1, int $perPage = 25) Functions to Work with a Base (Table Data) \u00b6 listRowsByView($table_name, $view_name = '') appendRow($table_name, $row) getBaseMetadata() More functions will be added in the future. If you want to get a feeling about the usage of the functions, please have a look at the examples in the doc folder. Common Mistakes \u00b6 There are two kind of Email-Addresses in SeaTable \u00b6 There are two kind of email-addresses in SeaTable. Please don't be confused with the property email . There are two email addresses in SeaTable. Let's have a look at the user object in SeaTable: { \"data\": [ { \"email\": \"1ef456ab715841cc81b145b2530c2904@auth.local\", \"name\": \"Jane Doe\", \"contact_email\": \"jane@example.com, ... } ], \"total_count\": 1 } SeaTable creates for every user a unique identifier in form of an email address in the form of 1ef456ab715841cc81b145b2530c2904@auth.local . This unique identifier is used by the API calls to identify a user like in deleteOrgUser() . On the other hand a user registers with an email address for SeaTable. In this example this email is jane@example.com . This is the contact_email and only relevant for the authentication.","title":"Overview"},{"location":"#seatable-api-php","text":"PHP-bindings of the SeaTable API ( api.seatable.io ).","title":"seatable-api-php"},{"location":"#requirements","text":"PHP 7.0+ (deprecated, 7.4+ recommended) with the Curl and Json extension (see composer.json ).","title":"Requirements"},{"location":"#installation","text":"The SeaTable API installs as part of your project dependencies. It is available from Packagist for Composer : composer require seatable/seatable-api-php","title":"Installation"},{"location":"#upgrading","text":"This project is with Semantic Versioning (2.0.0) . Please see the notes on upgrading , especially for upgrading from the SeaTableAPI.php single class/file and other very early versions (0.x).","title":"Upgrading"},{"location":"#usage","text":"","title":"Usage"},{"location":"#establish-the-connection","text":"<?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , 'password' => 'YOUR-PASSWORD' ]); // start using the available api calls echo $seatable -> ping ();","title":"Establish the Connection"},{"location":"#get-access-to-a-base","text":"SeaTable requires an additional authentication to get access to a specific base. There are two variants to obtain access. You can either: create within SeaTable an API-Token for a specific base - or - use your credentials, but then you have to provide the workspace_id and the name of the base. <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'YOUR-EMAIL' , # required for variant 2. 'password' => 'YOUR-PASSWORD' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // get access with your credentials (by workspace-id and table-name) $seatable -> getBaseAccessToken ( $workspaceID = 1323 , $name = 'Project tracker' ); // start using the available api calls to edit the data inside a base // ...","title":"Get Access to a Base"},{"location":"#functions","text":"","title":"Functions"},{"location":"#admin-functions-user","text":"sysAdminListUsers(int $page = 1, int $perPage = 25) getTotalUsers() sysAdminAddUser(string $email, string $name, string $password, string $role = 'default') sysAdminSearchUser(string $query) sysAdminUpdateUser(string $email, array $changes = []) activateUser($email) deactivateUser($email) sysAdminDeleteUser(string $email)","title":"Admin Functions (User)"},{"location":"#workspace-functions-admin","text":"listAllWorkspaces() listStarredWorkspaces() updateBase(int $workspaceId, string $baseName, array $changes = []) copyBaseExternalLink(string $link, int $destinationWorkspaceId)","title":"Workspace Functions (Admin)"},{"location":"#teammanagement-functions-admin","text":"Note: On the webpage SeaTable always talks about teams . The technical term that is used within the API documentation and manual is organization . sysAdminListTeams(int $page = 1, int $perPage = 25) sysAdminAddTeam(string $name, string $adminEmail, string $adminName, string $password, int $maxUser) sysAdminDeleteTeam(int $id) sysAdminUpdateTeam(int $id, array $changes = []) sysAdminListTeamUsers(int $id, int $page = 1, int $perPage = 25, bool $isStaff = false) sysAdminAddTeamUser(int $id, string $email, string $pass, string $name = null) sysAdminDeleteTeamUser(int $id, string $email) sysAdminListTeamGroups(int $id) sysAdminListTeamBases(int $id, int $page = 1, int $perPage = 25)","title":"Teammanagement Functions (Admin)"},{"location":"#functions-to-work-with-a-base-table-data","text":"listRowsByView($table_name, $view_name = '') appendRow($table_name, $row) getBaseMetadata() More functions will be added in the future. If you want to get a feeling about the usage of the functions, please have a look at the examples in the doc folder.","title":"Functions to Work with a Base (Table Data)"},{"location":"#common-mistakes","text":"","title":"Common Mistakes"},{"location":"#there-are-two-kind-of-email-addresses-in-seatable","text":"There are two kind of email-addresses in SeaTable. Please don't be confused with the property email . There are two email addresses in SeaTable. Let's have a look at the user object in SeaTable: { \"data\": [ { \"email\": \"1ef456ab715841cc81b145b2530c2904@auth.local\", \"name\": \"Jane Doe\", \"contact_email\": \"jane@example.com, ... } ], \"total_count\": 1 } SeaTable creates for every user a unique identifier in form of an email address in the form of 1ef456ab715841cc81b145b2530c2904@auth.local . This unique identifier is used by the API calls to identify a user like in deleteOrgUser() . On the other hand a user registers with an email address for SeaTable. In this example this email is jane@example.com . This is the contact_email and only relevant for the authentication.","title":"There are two kind of Email-Addresses in SeaTable"},{"location":"UPGRADING/","text":"Upgrading \u00b6 This project is with Semantic Versioning (2.0.0) . This means that for the major version zero anything may change. Therefore, to ease use already for early versions, upgrade instructions for any such changes can be found in this document for an easy upgrade path. From very early Versions \u00b6 Break of SeaTableApi::listOrgUsers() (0.1.20) Deprecation of SeaTableApi::getDTableToken() (0.1.11) Deprecation of PHP 7.0-7.3 (0.1.8) Removal of SeaTableAPI::debug() (0.1.7) New Classname (0.1.0) Curl SSL defaults (0.0.8) Upgrading from the SeaTableAPI.php Single Class/File (no version) Deprecations (0.x.x) Public Interface Break of SeaTableApi::listOrgUsers() (0.1.20) \u00b6 The $is_staff parameter of listOrgUsers() was broken and fixed in version 0.1.20. Unfortunately it could not be fixed without breaking backwards compatibility when using the $is_staff parameter. Previously when the $is_staff parameter was with the true default value, it was ineffective. Now the is_staff parameter is effective but the default value has changed to false . This ensures the behaviour is the same to previous but breaks in case the value true has been passed to obtain all users (admin and normal users) - true will now only return admin users. If true was in use to obtain all users, migrating to 0.1.20 requires to change $is_staff to false . Failing to do this will list admin users only . Upcoming Incompatible Changes in 0.2.x In 0.2.x the signature of the method will change with the $is_staff moved after the pagination parameters which will be swapped, too: 0.2.x: listOrgUsers(int $orgId, int $page = 1, int $perPage = 25, bool $isStaff = false): object 0.1.20: listOrgUsers($org_id, $is_staff = false, $per_page = 25, $page = 1) 0.1.19: listOrgUsers($org_id, $is_staff = true, $per_page = 25, $page = 1) Deprecation of SeaTableApi::getDTableToken() (0.1.11) \u00b6 The method getDTableToken() is deprecated. There are two new replacement methods to obtain a DTable Token: SeaTableApi::getBaseAppAccessToken() by the API Token SeaTableApi::getBaseAccessToken() by Workspace ID and DTable Name Deprecation of PHP 7.0-7.3 (0.1.8) \u00b6 With 0.1.8 the PHP versions below 7.4 are deprecated. Removal of SeaTableAPI::debug() (0.1.7) \u00b6 The in 0.0.4 deprecated SeaTableAPI::debug() method has been removed in 0.1.7. New Classname (0.1.0) \u00b6 If you previously used SeaTableAPI and you upgrade to version 0.1.0 or higher, replace it with SeaTableApi (lower-case pi at the end) from the new namespace SeaTable\\SeaTableApi . The use of the old class-name SeaTableAPI in the global namespace is deprecated with 0.1.0 and usages of the old class-name emit a deprecation notice ( E_USER_DEPRECATED ) on creation. Before: $seatable = new SeaTableAPI([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]); After: use SeaTable\\SeaTableApi\\SeaTableApi; $seatable = new SeaTableApi([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]); Curl SSL defaults (0.0.8) \u00b6 Version 0.0.8 changed to the cUrl library SSL defaults to improve security (and portability) for CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST . If you rely on non-default values for these two settings, you can pass them explicitly as options when creating the API class: $seatable = new SeaTableAPI([ 'http_options' => [ CURLOPT_SSL_VERIFYPEER => true, // always `false` before 0.0.8 CURLOPT_SSL_VERIFYHOST => 2, // always `false` before 0.0.8 ] ]); Upgrading from the SeaTableAPI.php Single Class/File (no version) \u00b6 If you previously just copied the SeaTableAPI.php file, you can replace it with the seatable/seatable-api-php composer package version 0.0.3: composer require seatable/seatable-api-php:0.0.3 Deprecations (0.x.x) \u00b6 For early versions, deprecations in the public interface are introduced not in minor but in patch versions. There is at least one patch version with the deprecation, and removal will not be before that patch version. Deprecations are @deprecated annotated and should trigger an E_USER_DEPRECATED error so that deprecations can be easily tracked while using. It then normally takes a couple of patch releases until a deprecated part of the public interface is fully removed. But note this must not necessarily be more than zero more patch releases and especially not a new minor release. However, expect the next minor release to not have the deprecated functionality any longer. In case it contains deprecation warnings from a previous minor release, expect it to not have the deprecated functionality any longer, the warning does not safeguard anything. To safely upgrade, test against your usage pattern with each patch version and handle the deprecations as early as possible. Public Interface \u00b6 Parts of the API marked as @internal are not part of the public interface and can change in any (patch) release. Parameters and return values in the public interface are still volatile and therefore not every of their properties can be easily guarded by deprecation warnings (or the PHP language itself). Even we do not take breaking changes lightly, please consider the following, more detailed information: Types of Parameters / Return Types \u00b6 If type-information for a parameter or a return value changes, the previous type-information unmatched by the change is considered deprecated, but not necessarily with a deprecation warning (for return-type-information a deprecation warning would likely not be useful if even possible). Run a type-checker to detect any issues with each patch release to be on the safe side: Changes in the signature (that have their effect with declare(strict_types=1) ) are not introduced in the same patch release unless the signature itself already contained the type-information for that parameter. That is before more strict and binding type-information is added, the information is annotated first. However, as the library uses declare(strict_types=1) internally, type errors may surface already earlier. Therefore, we suggest using the library with declare(strict_types=1) to narrow potential type related problems already when using the library. Named Parameters \u00b6 Calling any method or function of the public interface with named parameters (PHP 8.0+) is considered undefined behaviour. That is, it does not fall into any backward compatibility promise of any kind.","title":"Upgrading"},{"location":"UPGRADING/#upgrading","text":"This project is with Semantic Versioning (2.0.0) . This means that for the major version zero anything may change. Therefore, to ease use already for early versions, upgrade instructions for any such changes can be found in this document for an easy upgrade path.","title":"Upgrading"},{"location":"UPGRADING/#from-very-early-versions","text":"Break of SeaTableApi::listOrgUsers() (0.1.20) Deprecation of SeaTableApi::getDTableToken() (0.1.11) Deprecation of PHP 7.0-7.3 (0.1.8) Removal of SeaTableAPI::debug() (0.1.7) New Classname (0.1.0) Curl SSL defaults (0.0.8) Upgrading from the SeaTableAPI.php Single Class/File (no version) Deprecations (0.x.x) Public Interface","title":"From very early Versions"},{"location":"UPGRADING/#break-of-seatableapilistorgusers-0120","text":"The $is_staff parameter of listOrgUsers() was broken and fixed in version 0.1.20. Unfortunately it could not be fixed without breaking backwards compatibility when using the $is_staff parameter. Previously when the $is_staff parameter was with the true default value, it was ineffective. Now the is_staff parameter is effective but the default value has changed to false . This ensures the behaviour is the same to previous but breaks in case the value true has been passed to obtain all users (admin and normal users) - true will now only return admin users. If true was in use to obtain all users, migrating to 0.1.20 requires to change $is_staff to false . Failing to do this will list admin users only . Upcoming Incompatible Changes in 0.2.x In 0.2.x the signature of the method will change with the $is_staff moved after the pagination parameters which will be swapped, too: 0.2.x: listOrgUsers(int $orgId, int $page = 1, int $perPage = 25, bool $isStaff = false): object 0.1.20: listOrgUsers($org_id, $is_staff = false, $per_page = 25, $page = 1) 0.1.19: listOrgUsers($org_id, $is_staff = true, $per_page = 25, $page = 1)","title":"Break of SeaTableApi::listOrgUsers() (0.1.20)"},{"location":"UPGRADING/#deprecation-of-seatableapigetdtabletoken-0111","text":"The method getDTableToken() is deprecated. There are two new replacement methods to obtain a DTable Token: SeaTableApi::getBaseAppAccessToken() by the API Token SeaTableApi::getBaseAccessToken() by Workspace ID and DTable Name","title":"Deprecation of SeaTableApi::getDTableToken() (0.1.11)"},{"location":"UPGRADING/#deprecation-of-php-70-73-018","text":"With 0.1.8 the PHP versions below 7.4 are deprecated.","title":"Deprecation of PHP 7.0-7.3 (0.1.8)"},{"location":"UPGRADING/#removal-of-seatableapidebug-017","text":"The in 0.0.4 deprecated SeaTableAPI::debug() method has been removed in 0.1.7.","title":"Removal of SeaTableAPI::debug() (0.1.7)"},{"location":"UPGRADING/#new-classname-010","text":"If you previously used SeaTableAPI and you upgrade to version 0.1.0 or higher, replace it with SeaTableApi (lower-case pi at the end) from the new namespace SeaTable\\SeaTableApi . The use of the old class-name SeaTableAPI in the global namespace is deprecated with 0.1.0 and usages of the old class-name emit a deprecation notice ( E_USER_DEPRECATED ) on creation. Before: $seatable = new SeaTableAPI([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]); After: use SeaTable\\SeaTableApi\\SeaTableApi; $seatable = new SeaTableApi([ 'url' => 'https://cloud.seatable.io', 'user' => 'demo@example.com', 'password' => 'very-secure-password' ]);","title":"New Classname (0.1.0)"},{"location":"UPGRADING/#curl-ssl-defaults-008","text":"Version 0.0.8 changed to the cUrl library SSL defaults to improve security (and portability) for CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST . If you rely on non-default values for these two settings, you can pass them explicitly as options when creating the API class: $seatable = new SeaTableAPI([ 'http_options' => [ CURLOPT_SSL_VERIFYPEER => true, // always `false` before 0.0.8 CURLOPT_SSL_VERIFYHOST => 2, // always `false` before 0.0.8 ] ]);","title":"Curl SSL defaults (0.0.8)"},{"location":"UPGRADING/#upgrading-from-the-seatableapiphp-single-classfile-no-version","text":"If you previously just copied the SeaTableAPI.php file, you can replace it with the seatable/seatable-api-php composer package version 0.0.3: composer require seatable/seatable-api-php:0.0.3","title":"Upgrading from the SeaTableAPI.php Single Class/File (no version)"},{"location":"UPGRADING/#deprecations-0xx","text":"For early versions, deprecations in the public interface are introduced not in minor but in patch versions. There is at least one patch version with the deprecation, and removal will not be before that patch version. Deprecations are @deprecated annotated and should trigger an E_USER_DEPRECATED error so that deprecations can be easily tracked while using. It then normally takes a couple of patch releases until a deprecated part of the public interface is fully removed. But note this must not necessarily be more than zero more patch releases and especially not a new minor release. However, expect the next minor release to not have the deprecated functionality any longer. In case it contains deprecation warnings from a previous minor release, expect it to not have the deprecated functionality any longer, the warning does not safeguard anything. To safely upgrade, test against your usage pattern with each patch version and handle the deprecations as early as possible.","title":"Deprecations (0.x.x)"},{"location":"UPGRADING/#public-interface","text":"Parts of the API marked as @internal are not part of the public interface and can change in any (patch) release. Parameters and return values in the public interface are still volatile and therefore not every of their properties can be easily guarded by deprecation warnings (or the PHP language itself). Even we do not take breaking changes lightly, please consider the following, more detailed information:","title":"Public Interface"},{"location":"UPGRADING/#types-of-parameters-return-types","text":"If type-information for a parameter or a return value changes, the previous type-information unmatched by the change is considered deprecated, but not necessarily with a deprecation warning (for return-type-information a deprecation warning would likely not be useful if even possible). Run a type-checker to detect any issues with each patch release to be on the safe side: Changes in the signature (that have their effect with declare(strict_types=1) ) are not introduced in the same patch release unless the signature itself already contained the type-information for that parameter. That is before more strict and binding type-information is added, the information is annotated first. However, as the library uses declare(strict_types=1) internally, type errors may surface already earlier. Therefore, we suggest using the library with declare(strict_types=1) to narrow potential type related problems already when using the library.","title":"Types of Parameters / Return Types"},{"location":"UPGRADING/#named-parameters","text":"Calling any method or function of the public interface with named parameters (PHP 8.0+) is considered undefined behaviour. That is, it does not fall into any backward compatibility promise of any kind.","title":"Named Parameters"},{"location":"doc/add-new-column-to-base/","text":"Example: Add a new Column to a Base \u00b6 Prerequisites \u00b6 You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read and write) the name of the table and the columns inside the base like table-name: Tasks columns of this table: Name , Description Example PHP-code \u00b6 <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // Append a row $row = [ 'Name' => \"New Task XYZ\" , 'Description' => \"This is a new description\" ]; $result = $seatable -> appendRow ( 'Tasks' , $row );","title":"Add a new Column to a Base"},{"location":"doc/add-new-column-to-base/#example-add-a-new-column-to-a-base","text":"","title":"Example: Add a new Column to a Base"},{"location":"doc/add-new-column-to-base/#prerequisites","text":"You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read and write) the name of the table and the columns inside the base like table-name: Tasks columns of this table: Name , Description","title":"Prerequisites"},{"location":"doc/add-new-column-to-base/#example-php-code","text":"<?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( '1d3303315348c6b566c44709d459b33b6bac5ad1' ); // Append a row $row = [ 'Name' => \"New Task XYZ\" , 'Description' => \"This is a new description\" ]; $result = $seatable -> appendRow ( 'Tasks' , $row );","title":"Example PHP-code"},{"location":"doc/get-content-from-a-base/","text":"Example: Get Content from a Base \u00b6 Prerequisites \u00b6 You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read-only is enough) the name of the table like Articles the columns of this table: Status (single select) Description Title URL Example PHP-code \u00b6 <?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b577c44709d459b33b6bac5ad1' ); // get all rows from the table Articles $rows = $seatable -> listRowsByView ( 'Articles' ); $reportsHtml = ' <ul class=\"my-reports\">' ; foreach ( $rows as $row ){ if ( $row -> Status === 'published' ) { $reportsHtml .= ' <li> <h2><a href=\"' . $row -> URL . '\" target=\"_blank\">' . htmlspecialchars ( $row -> Title , ENT_QUOTES | ENT_HTML5 ) . '</a></h2> <div class=\"desc> <p>' . htmlspecialchars ( $row -> Description , ENT_QUOTES | ENT_HTML5 ) . '</p> </div> </li>' ; }} $reportsHtml .= ' </ul>' ; echo $reportsHtml ;","title":"Get Content from a Base"},{"location":"doc/get-content-from-a-base/#example-get-content-from-a-base","text":"","title":"Example: Get Content from a Base"},{"location":"doc/get-content-from-a-base/#prerequisites","text":"You need: a SeaTable account like demo@example.com an API-key for a base like 1d3303315348c6b566c44709d459b33b6bac5ad1 (read-only is enough) the name of the table like Articles the columns of this table: Status (single select) Description Title URL","title":"Prerequisites"},{"location":"doc/get-content-from-a-base/#example-php-code","text":"<?php declare ( strict_types = 1 ); // setting up autoloader require_once __DIR__ . '/../vendor/autoload.php' ; // use SeaTable api class use SeaTable\\SeaTableApi\\SeaTableApi ; // init and obtain auth token $seatable = new SeaTableApi ([ 'url' => 'https://cloud.seatable.io' , 'user' => 'demo@example.com' , 'password' => 'very-secure-password' ]); // get access with an api-token for a base $seatable -> getBaseAppAccessToken ( $token = '1d3303315348c6b577c44709d459b33b6bac5ad1' ); // get all rows from the table Articles $rows = $seatable -> listRowsByView ( 'Articles' ); $reportsHtml = ' <ul class=\"my-reports\">' ; foreach ( $rows as $row ){ if ( $row -> Status === 'published' ) { $reportsHtml .= ' <li> <h2><a href=\"' . $row -> URL . '\" target=\"_blank\">' . htmlspecialchars ( $row -> Title , ENT_QUOTES | ENT_HTML5 ) . '</a></h2> <div class=\"desc> <p>' . htmlspecialchars ( $row -> Description , ENT_QUOTES | ENT_HTML5 ) . '</p> </div> </li>' ; }} $reportsHtml .= ' </ul>' ; echo $reportsHtml ;","title":"Example PHP-code"}]}